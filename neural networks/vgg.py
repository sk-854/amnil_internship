# -*- coding: utf-8 -*-
"""vgg

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CuFvyaNsIlgMbNzfZzeNO8zMeTowTCr_
"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers, models
from tensorflow.keras.applications.vgg16 import preprocess_input
from tensorflow.keras.applications import DenseNet121
from tensorflow.keras.applications import VGG16
import tensorflow_datasets as tfds
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay
import numpy as np

dataset_name = "imagenette"
full_dataset, info = tfds.load(dataset_name, with_info=True, split="train", as_supervised=True)

print(info)  # Check classes, number of images, etc.

num_classes = info.features['label'].num_classes  # Should be 10 for Imagenette
print("Number of classes:", num_classes)

class_names = info.features['label'].names  # List of class names
print("Classes:", class_names)

#Normalizing image
IMG_SIZE = 224 #128*128 ma resize
BATCH_SIZE = 32
AUTOTUNE = tf.data.AUTOTUNE

def preprocess(image, label):
    image = tf.image.resize(image, (IMG_SIZE, IMG_SIZE))
    image=image/255.0
    return image, label

full_dataset = full_dataset.map(preprocess, num_parallel_calls=AUTOTUNE)

def show_samples(dataset, class_names, n=9):
    plt.figure(figsize=(8,8))
    for i, (img, lbl) in enumerate(dataset.take(n)):
        ax = plt.subplot(3,3,i+1)
        plt.imshow(img.numpy())
        ax.set_title(class_names[int(lbl)])
        ax.axis('off')
    plt.tight_layout()
    plt.show()

# Take a small subset to visualize
show_samples(full_dataset, class_names, n=9)

dataset_size = 946  # imagenette 160 subset train size; adjust if using full dataset
train_size = int(0.8 * dataset_size)
val_size = dataset_size - train_size

train_ds = full_dataset.take(train_size)
val_ds = full_dataset.skip(train_size)

# Batch and prefetch
train_ds = train_ds.shuffle(1000).batch(BATCH_SIZE).prefetch(AUTOTUNE)
val_ds = val_ds.batch(BATCH_SIZE).prefetch(AUTOTUNE)

base_model = VGG16(weights='imagenet', include_top=False, input_shape=(IMG_SIZE, IMG_SIZE, 3))
base_model.trainable = False  # freeze base layers


num_classes = len(class_names)
model = models.Sequential([
    base_model,
    layers.Flatten(),
    layers.Dense(256, activation='relu'),
    layers.Dropout(0.5),
    layers.Dense(num_classes, activation='softmax')
])

model.summary()

#model compile
model.compile(
    optimizer=tf.keras.optimizers.Adam(learning_rate=1e-4),
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

#model train
EPOCHS = 5
history = model.fit(train_ds, validation_data=val_ds, epochs=EPOCHS)

#model Evaluation
val_loss, val_acc = model.evaluate(val_ds)
print(f"\nValidation Loss: {val_loss:.4f}, Validation Accuracy: {val_acc:.4f}")

# Predict labels for confusion matrix and classification report
y_true, y_pred = [], []
for images, labels in val_ds:
    preds = np.argmax(model.predict(images, verbose=0), axis=1)
    y_true.extend(labels.numpy())
    y_pred.extend(preds)

#Classification report
print("\nClassification Report:")
print(classification_report(y_true, y_pred, target_names=class_names))

#Confusion Matrix
cm = confusion_matrix(y_true, y_pred)
plt.figure(figsize=(8,6))
plt.imshow(cm, cmap='Blues', interpolation='nearest')
plt.title("Confusion Matrix")
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.xticks(range(num_classes), class_names, rotation=90)
plt.yticks(range(num_classes), class_names)
plt.colorbar()
plt.tight_layout()
plt.show()

#some predictions
examples = val_ds.unbatch().take(12)  # take 12 examples
plt.figure(figsize=(12,8))
for i, (img, lbl) in enumerate(examples):
    ax = plt.subplot(3,4,i+1)
    img_input = tf.expand_dims(img, 0)  # model expects batch dimension
    probs = model.predict(img_input, verbose=0)
    pred = np.argmax(probs)
    conf = np.max(probs)
    plt.imshow(img.numpy())
    ax.set_title(f"P:{class_names[pred]}\nA:{class_names[int(lbl)]}\nConf:{conf:.2f}", fontsize=9)
    ax.axis('off')
plt.tight_layout()
plt.show()